* Lazily

This package simply provides the macro =lazily-do= for use in Emacs
configuration files. It only does one thing. You can wrap any configuration
steps in the macro without having to worry about void-variable messages or
void-function errors. In the example below =good-list= is declared, but Emacs
doesn't know about =bad-list= or =bad-func= yet. This would throw a
void-variable error. Execution stops here and we don't get to =bad-func=, which
would throw a void-function error.

#+BEGIN_SRC emacs-lisp
  (defvar good-list nil)
  (add-to-list 'good-list 1)
  (add-to-list 'bad-list 1)
  (bad-func))
#+END_SRC

We have a couple of options here. We could figure out which library defines
=bad-list= and =bad-func=. This is usually easy but not always. Did you know
that =org-latex-classes= is initialized in =ox-latex=? If =ox-latex= isn't
loaded, Emacs doesn't know this either. To fix this we could =(require
'ox-latex)= or use =with-eval-after-load= like this

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'bad-library
   (add-to-list 'bad-list 1)
   (bad-func))
#+END_SRC

The way =lazily-do= works is it stores the forms in a list and tries again to
eval those forms (in order) every time a new library is loaded. It accomplishes
this through using the =after-load-functions= hook. To illustrate suppose we
modified the example to this.

#+BEGIN_SRC emacs-lisp
  (defvar good-list nil)
  (lazily-do
   (add-to-list 'good-list 1)
   (add-to-list 'bad-list 1)
   (bad-func))
#+END_SRC

The form with =good-list= will execute fine and there will be no difference to
having this form at the top level. The one with =bad-list= throws a
void-variable error which is caught and the form is saved for later. The one
with =bad-func= throws a void-function error and is caught and saved, too. We do
some work and eventually something calls or loads =bad-library=. This fires
=lazily--redo= to try the saved forms again, and now that =bad-list= is defined
the original error goes away and everything is dandy.

** Implementation notes
   - =lazily-do= is greedy in that after finding a form that throws an error it
     keeps going until all the forms are processed. If you require that some
     code execute before other code, this is easily taken care of by grouping
     forms using a construct like =progn=. For example, something like this
     could be done. 
     #+BEGIN_SRC emacs-lisp
       (defvar good-list nil)
       (lazily-do
        (add-to-list 'good-list 1)
        (progn
          (add-to-list 'bad-list 1)
          (bad-func)))
     #+END_SRC
     Without the =progn=, if at some point =bad-func= was defined and =bad-list=
     was not, then =lazily= would try to execute =bad-func= by itself. With the
     =progn= this can't happen, because the =progn= is taken to be one form and
     is stored as a single unit.

** Configuration options
   - =lazily-is-quiet=: Set this variable to =nil= if you want to log bad forms
     when they are found.
